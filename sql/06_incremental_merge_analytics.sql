-- Task 1: Transform landing → target + rejected --

CREATE OR REPLACE TASK t01_transform_orders
WAREHOUSE = TRANSFORM_WH
SCHEDULE = '10 MINUTE'
WHEN SYSTEM$STREAM_HAS_DATA('RAW.ORDERS_STREAM')
AS
BEGIN
  -- valid → target
  INSERT INTO RAW.target_table_orders (
    ORDER_ID, CUSTOMER_ID, PRODUCT_ID, QUANTITY, PAYMENT_METHOD, CREATED_AT
  )
  SELECT
    ORDER_ID, CUSTOMER_ID, PRODUCT_ID,
    TRY_TO_NUMBER(QUANTITY),
    PAYMENT_METHOD,
    TRY_TO_TIMESTAMP_NTZ(CREATED_AT)
  FROM RAW.STG_ORDERS_LANDING
  WHERE TRY_TO_NUMBER(QUANTITY) IS NOT NULL
    AND TRY_TO_TIMESTAMP_NTZ(CREATED_AT) IS NOT NULL;

  -- invalid → rejected
  INSERT INTO RAW.raw_sales_orders_rejected (
    ORDER_ID, CUSTOMER_ID, PRODUCT_ID, QUANTITY, PAYMENT_METHOD, CREATED_AT, LOAD_TIME, ERROR_REASON
  )
  SELECT
    ORDER_ID, CUSTOMER_ID, PRODUCT_ID, QUANTITY, PAYMENT_METHOD, CREATED_AT, LOAD_TIME,
    CONCAT(
      IFF(TRY_TO_NUMBER(QUANTITY) IS NULL, 'Invalid QUANTITY; ', ''),
      IFF(TRY_TO_TIMESTAMP_NTZ(CREATED_AT) IS NULL, 'Invalid CREATED_AT; ', '')
    )
  FROM RAW.STG_ORDERS_LANDING
  WHERE TRY_TO_NUMBER(QUANTITY) IS NULL
     OR TRY_TO_TIMESTAMP_NTZ(CREATED_AT) IS NULL;
END;




-- Chain the Analytics Task after Transform Task --
// Step 5 analytics incremental task should run only after target is updated.
// Remove schedule from second task and set dependency:

CREATE OR REPLACE TASK t02_analytics_incremental
WAREHOUSE = TRANSFORM_WH
AFTER t01_transform_orders
WHEN SYSTEM$STREAM_HAS_DATA('RAW.TARGET_ORDERS_STREAM')
AS
BEGIN
  -- MERGE DIM + FACT (same logic as Step 5.4)
  -- DIM_CUSTOMER
  MERGE INTO ANALYTICS.DIM_CUSTOMER d
  USING (
    SELECT DISTINCT CUSTOMER_ID
    FROM RAW.TARGET_ORDERS_STREAM
    WHERE CUSTOMER_ID IS NOT NULL
  ) s
  ON d.CUSTOMER_ID = s.CUSTOMER_ID
  WHEN NOT MATCHED THEN
    INSERT (CUSTOMER_ID) VALUES (s.CUSTOMER_ID);

  -- DIM_PRODUCT
  MERGE INTO ANALYTICS.DIM_PRODUCT d
  USING (
    SELECT DISTINCT PRODUCT_ID
    FROM RAW.TARGET_ORDERS_STREAM
    WHERE PRODUCT_ID IS NOT NULL
  ) s
  ON d.PRODUCT_ID = s.PRODUCT_ID
  WHEN NOT MATCHED THEN
    INSERT (PRODUCT_ID) VALUES (s.PRODUCT_ID);

  -- FACT_ORDERS
  MERGE INTO ANALYTICS.FACT_ORDERS f
  USING (
    SELECT
      t.ORDER_ID,
      c.CUSTOMER_KEY,
      p.PRODUCT_KEY,
      TO_NUMBER(TO_CHAR(t.CREATED_AT::DATE, 'YYYYMMDD')) AS DATE_KEY,
      t.QUANTITY,
      t.PAYMENT_METHOD,
      t.LOAD_TIME
    FROM RAW.TARGET_ORDERS_STREAM t
    JOIN ANALYTICS.DIM_CUSTOMER c ON t.CUSTOMER_ID = c.CUSTOMER_ID
    JOIN ANALYTICS.DIM_PRODUCT  p ON t.PRODUCT_ID = p.PRODUCT_ID
    WHERE t.CREATED_AT IS NOT NULL
  ) s
  ON f.ORDER_ID = s.ORDER_ID
  WHEN MATCHED THEN UPDATE SET
    CUSTOMER_KEY    = s.CUSTOMER_KEY,
    PRODUCT_KEY     = s.PRODUCT_KEY,
    DATE_KEY        = s.DATE_KEY,
    QUANTITY        = s.QUANTITY,
    PAYMENT_METHOD  = s.PAYMENT_METHOD,
    LOAD_TIME       = s.LOAD_TIME
  WHEN NOT MATCHED THEN
    INSERT (ORDER_ID, CUSTOMER_KEY, PRODUCT_KEY, DATE_KEY, QUANTITY, PAYMENT_METHOD, LOAD_TIME)
    VALUES (s.ORDER_ID, s.CUSTOMER_KEY, s.PRODUCT_KEY, s.DATE_KEY, s.QUANTITY, s.PAYMENT_METHOD, s.LOAD_TIME);
END;
// This gives you chaining: t01_transform_orders → t02_analytics_incremental


ALTER TASK t02_analytics_incremental RESUME;
ALTER TASK t01_transform_orders RESUME; // order is matter child -> parent 


SELECT *
FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(
  SCHEDULED_TIME_RANGE_START => DATEADD('HOUR', -24, CURRENT_TIMESTAMP()),
  SCHEDULED_TIME_RANGE_END   => CURRENT_TIMESTAMP()
))
ORDER BY SCHEDULED_TIME DESC; // See task execution history


SHOW TASKS IN DATABASE SALES_DB; //See task graph (dependency)




